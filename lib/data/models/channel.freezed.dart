// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'channel.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Channel _$ChannelFromJson(Map<String, dynamic> json) {
  return _Channel.fromJson(json);
}

/// @nodoc
mixin _$Channel {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get logo => throw _privateConstructorUsedError;
  String get country => throw _privateConstructorUsedError;
  String? get category => throw _privateConstructorUsedError;
  String get streamUrl => throw _privateConstructorUsedError;
  StreamQuality get quality => throw _privateConstructorUsedError;
  bool get isNsfw => throw _privateConstructorUsedError;
  HealthStatus get health => throw _privateConstructorUsedError;
  List<String>? get altNames => throw _privateConstructorUsedError;
  String? get network => throw _privateConstructorUsedError;
  String? get website => throw _privateConstructorUsedError;
  String? get referrer => throw _privateConstructorUsedError;
  String? get userAgent => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChannelCopyWith<Channel> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChannelCopyWith<$Res> {
  factory $ChannelCopyWith(Channel value, $Res Function(Channel) then) =
      _$ChannelCopyWithImpl<$Res, Channel>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? logo,
      String country,
      String? category,
      String streamUrl,
      StreamQuality quality,
      bool isNsfw,
      HealthStatus health,
      List<String>? altNames,
      String? network,
      String? website,
      String? referrer,
      String? userAgent});
}

/// @nodoc
class _$ChannelCopyWithImpl<$Res, $Val extends Channel>
    implements $ChannelCopyWith<$Res> {
  _$ChannelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? logo = freezed,
    Object? country = null,
    Object? category = freezed,
    Object? streamUrl = null,
    Object? quality = null,
    Object? isNsfw = null,
    Object? health = null,
    Object? altNames = freezed,
    Object? network = freezed,
    Object? website = freezed,
    Object? referrer = freezed,
    Object? userAgent = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      logo: freezed == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String?,
      streamUrl: null == streamUrl
          ? _value.streamUrl
          : streamUrl // ignore: cast_nullable_to_non_nullable
              as String,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as StreamQuality,
      isNsfw: null == isNsfw
          ? _value.isNsfw
          : isNsfw // ignore: cast_nullable_to_non_nullable
              as bool,
      health: null == health
          ? _value.health
          : health // ignore: cast_nullable_to_non_nullable
              as HealthStatus,
      altNames: freezed == altNames
          ? _value.altNames
          : altNames // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as String?,
      website: freezed == website
          ? _value.website
          : website // ignore: cast_nullable_to_non_nullable
              as String?,
      referrer: freezed == referrer
          ? _value.referrer
          : referrer // ignore: cast_nullable_to_non_nullable
              as String?,
      userAgent: freezed == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChannelImplCopyWith<$Res> implements $ChannelCopyWith<$Res> {
  factory _$$ChannelImplCopyWith(
          _$ChannelImpl value, $Res Function(_$ChannelImpl) then) =
      __$$ChannelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? logo,
      String country,
      String? category,
      String streamUrl,
      StreamQuality quality,
      bool isNsfw,
      HealthStatus health,
      List<String>? altNames,
      String? network,
      String? website,
      String? referrer,
      String? userAgent});
}

/// @nodoc
class __$$ChannelImplCopyWithImpl<$Res>
    extends _$ChannelCopyWithImpl<$Res, _$ChannelImpl>
    implements _$$ChannelImplCopyWith<$Res> {
  __$$ChannelImplCopyWithImpl(
      _$ChannelImpl _value, $Res Function(_$ChannelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? logo = freezed,
    Object? country = null,
    Object? category = freezed,
    Object? streamUrl = null,
    Object? quality = null,
    Object? isNsfw = null,
    Object? health = null,
    Object? altNames = freezed,
    Object? network = freezed,
    Object? website = freezed,
    Object? referrer = freezed,
    Object? userAgent = freezed,
  }) {
    return _then(_$ChannelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      logo: freezed == logo
          ? _value.logo
          : logo // ignore: cast_nullable_to_non_nullable
              as String?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String?,
      streamUrl: null == streamUrl
          ? _value.streamUrl
          : streamUrl // ignore: cast_nullable_to_non_nullable
              as String,
      quality: null == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as StreamQuality,
      isNsfw: null == isNsfw
          ? _value.isNsfw
          : isNsfw // ignore: cast_nullable_to_non_nullable
              as bool,
      health: null == health
          ? _value.health
          : health // ignore: cast_nullable_to_non_nullable
              as HealthStatus,
      altNames: freezed == altNames
          ? _value._altNames
          : altNames // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as String?,
      website: freezed == website
          ? _value.website
          : website // ignore: cast_nullable_to_non_nullable
              as String?,
      referrer: freezed == referrer
          ? _value.referrer
          : referrer // ignore: cast_nullable_to_non_nullable
              as String?,
      userAgent: freezed == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChannelImpl implements _Channel {
  const _$ChannelImpl(
      {required this.id,
      required this.name,
      this.logo,
      required this.country,
      this.category,
      required this.streamUrl,
      this.quality = StreamQuality.unknown,
      this.isNsfw = false,
      this.health = HealthStatus.unknown,
      final List<String>? altNames,
      this.network,
      this.website,
      this.referrer,
      this.userAgent})
      : _altNames = altNames;

  factory _$ChannelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChannelImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String? logo;
  @override
  final String country;
  @override
  final String? category;
  @override
  final String streamUrl;
  @override
  @JsonKey()
  final StreamQuality quality;
  @override
  @JsonKey()
  final bool isNsfw;
  @override
  @JsonKey()
  final HealthStatus health;
  final List<String>? _altNames;
  @override
  List<String>? get altNames {
    final value = _altNames;
    if (value == null) return null;
    if (_altNames is EqualUnmodifiableListView) return _altNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? network;
  @override
  final String? website;
  @override
  final String? referrer;
  @override
  final String? userAgent;

  @override
  String toString() {
    return 'Channel(id: $id, name: $name, logo: $logo, country: $country, category: $category, streamUrl: $streamUrl, quality: $quality, isNsfw: $isNsfw, health: $health, altNames: $altNames, network: $network, website: $website, referrer: $referrer, userAgent: $userAgent)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChannelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.logo, logo) || other.logo == logo) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.streamUrl, streamUrl) ||
                other.streamUrl == streamUrl) &&
            (identical(other.quality, quality) || other.quality == quality) &&
            (identical(other.isNsfw, isNsfw) || other.isNsfw == isNsfw) &&
            (identical(other.health, health) || other.health == health) &&
            const DeepCollectionEquality().equals(other._altNames, _altNames) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.website, website) || other.website == website) &&
            (identical(other.referrer, referrer) ||
                other.referrer == referrer) &&
            (identical(other.userAgent, userAgent) ||
                other.userAgent == userAgent));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      logo,
      country,
      category,
      streamUrl,
      quality,
      isNsfw,
      health,
      const DeepCollectionEquality().hash(_altNames),
      network,
      website,
      referrer,
      userAgent);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChannelImplCopyWith<_$ChannelImpl> get copyWith =>
      __$$ChannelImplCopyWithImpl<_$ChannelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChannelImplToJson(
      this,
    );
  }
}

abstract class _Channel implements Channel {
  const factory _Channel(
      {required final String id,
      required final String name,
      final String? logo,
      required final String country,
      final String? category,
      required final String streamUrl,
      final StreamQuality quality,
      final bool isNsfw,
      final HealthStatus health,
      final List<String>? altNames,
      final String? network,
      final String? website,
      final String? referrer,
      final String? userAgent}) = _$ChannelImpl;

  factory _Channel.fromJson(Map<String, dynamic> json) = _$ChannelImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String? get logo;
  @override
  String get country;
  @override
  String? get category;
  @override
  String get streamUrl;
  @override
  StreamQuality get quality;
  @override
  bool get isNsfw;
  @override
  HealthStatus get health;
  @override
  List<String>? get altNames;
  @override
  String? get network;
  @override
  String? get website;
  @override
  String? get referrer;
  @override
  String? get userAgent;
  @override
  @JsonKey(ignore: true)
  _$$ChannelImplCopyWith<_$ChannelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChannelCategory _$ChannelCategoryFromJson(Map<String, dynamic> json) {
  return _ChannelCategory.fromJson(json);
}

/// @nodoc
mixin _$ChannelCategory {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChannelCategoryCopyWith<ChannelCategory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChannelCategoryCopyWith<$Res> {
  factory $ChannelCategoryCopyWith(
          ChannelCategory value, $Res Function(ChannelCategory) then) =
      _$ChannelCategoryCopyWithImpl<$Res, ChannelCategory>;
  @useResult
  $Res call({String id, String name, String? description});
}

/// @nodoc
class _$ChannelCategoryCopyWithImpl<$Res, $Val extends ChannelCategory>
    implements $ChannelCategoryCopyWith<$Res> {
  _$ChannelCategoryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChannelCategoryImplCopyWith<$Res>
    implements $ChannelCategoryCopyWith<$Res> {
  factory _$$ChannelCategoryImplCopyWith(_$ChannelCategoryImpl value,
          $Res Function(_$ChannelCategoryImpl) then) =
      __$$ChannelCategoryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, String? description});
}

/// @nodoc
class __$$ChannelCategoryImplCopyWithImpl<$Res>
    extends _$ChannelCategoryCopyWithImpl<$Res, _$ChannelCategoryImpl>
    implements _$$ChannelCategoryImplCopyWith<$Res> {
  __$$ChannelCategoryImplCopyWithImpl(
      _$ChannelCategoryImpl _value, $Res Function(_$ChannelCategoryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = freezed,
  }) {
    return _then(_$ChannelCategoryImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChannelCategoryImpl implements _ChannelCategory {
  const _$ChannelCategoryImpl(
      {required this.id, required this.name, this.description});

  factory _$ChannelCategoryImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChannelCategoryImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String? description;

  @override
  String toString() {
    return 'ChannelCategory(id: $id, name: $name, description: $description)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChannelCategoryImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChannelCategoryImplCopyWith<_$ChannelCategoryImpl> get copyWith =>
      __$$ChannelCategoryImplCopyWithImpl<_$ChannelCategoryImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChannelCategoryImplToJson(
      this,
    );
  }
}

abstract class _ChannelCategory implements ChannelCategory {
  const factory _ChannelCategory(
      {required final String id,
      required final String name,
      final String? description}) = _$ChannelCategoryImpl;

  factory _ChannelCategory.fromJson(Map<String, dynamic> json) =
      _$ChannelCategoryImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$ChannelCategoryImplCopyWith<_$ChannelCategoryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Country _$CountryFromJson(Map<String, dynamic> json) {
  return _Country.fromJson(json);
}

/// @nodoc
mixin _$Country {
  String get name => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;
  String? get flag => throw _privateConstructorUsedError;
  List<String> get languages => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CountryCopyWith<Country> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountryCopyWith<$Res> {
  factory $CountryCopyWith(Country value, $Res Function(Country) then) =
      _$CountryCopyWithImpl<$Res, Country>;
  @useResult
  $Res call({String name, String code, String? flag, List<String> languages});
}

/// @nodoc
class _$CountryCopyWithImpl<$Res, $Val extends Country>
    implements $CountryCopyWith<$Res> {
  _$CountryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? code = null,
    Object? flag = freezed,
    Object? languages = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      flag: freezed == flag
          ? _value.flag
          : flag // ignore: cast_nullable_to_non_nullable
              as String?,
      languages: null == languages
          ? _value.languages
          : languages // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CountryImplCopyWith<$Res> implements $CountryCopyWith<$Res> {
  factory _$$CountryImplCopyWith(
          _$CountryImpl value, $Res Function(_$CountryImpl) then) =
      __$$CountryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String code, String? flag, List<String> languages});
}

/// @nodoc
class __$$CountryImplCopyWithImpl<$Res>
    extends _$CountryCopyWithImpl<$Res, _$CountryImpl>
    implements _$$CountryImplCopyWith<$Res> {
  __$$CountryImplCopyWithImpl(
      _$CountryImpl _value, $Res Function(_$CountryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? code = null,
    Object? flag = freezed,
    Object? languages = null,
  }) {
    return _then(_$CountryImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      flag: freezed == flag
          ? _value.flag
          : flag // ignore: cast_nullable_to_non_nullable
              as String?,
      languages: null == languages
          ? _value._languages
          : languages // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CountryImpl implements _Country {
  const _$CountryImpl(
      {required this.name,
      required this.code,
      this.flag,
      final List<String> languages = const []})
      : _languages = languages;

  factory _$CountryImpl.fromJson(Map<String, dynamic> json) =>
      _$$CountryImplFromJson(json);

  @override
  final String name;
  @override
  final String code;
  @override
  final String? flag;
  final List<String> _languages;
  @override
  @JsonKey()
  List<String> get languages {
    if (_languages is EqualUnmodifiableListView) return _languages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_languages);
  }

  @override
  String toString() {
    return 'Country(name: $name, code: $code, flag: $flag, languages: $languages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CountryImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.flag, flag) || other.flag == flag) &&
            const DeepCollectionEquality()
                .equals(other._languages, _languages));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, code, flag,
      const DeepCollectionEquality().hash(_languages));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CountryImplCopyWith<_$CountryImpl> get copyWith =>
      __$$CountryImplCopyWithImpl<_$CountryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CountryImplToJson(
      this,
    );
  }
}

abstract class _Country implements Country {
  const factory _Country(
      {required final String name,
      required final String code,
      final String? flag,
      final List<String> languages}) = _$CountryImpl;

  factory _Country.fromJson(Map<String, dynamic> json) = _$CountryImpl.fromJson;

  @override
  String get name;
  @override
  String get code;
  @override
  String? get flag;
  @override
  List<String> get languages;
  @override
  @JsonKey(ignore: true)
  _$$CountryImplCopyWith<_$CountryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StreamInfo _$StreamInfoFromJson(Map<String, dynamic> json) {
  return _StreamInfo.fromJson(json);
}

/// @nodoc
mixin _$StreamInfo {
  String? get channel =>
      throw _privateConstructorUsedError; // CAN BE NULL in API!
  String? get feed => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError; // CAN BE NULL in API!
  String? get referrer => throw _privateConstructorUsedError;
  @JsonKey(name: 'user_agent')
  String? get userAgent => throw _privateConstructorUsedError;
  String? get quality => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StreamInfoCopyWith<StreamInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StreamInfoCopyWith<$Res> {
  factory $StreamInfoCopyWith(
          StreamInfo value, $Res Function(StreamInfo) then) =
      _$StreamInfoCopyWithImpl<$Res, StreamInfo>;
  @useResult
  $Res call(
      {String? channel,
      String? feed,
      String? title,
      String? url,
      String? referrer,
      @JsonKey(name: 'user_agent') String? userAgent,
      String? quality});
}

/// @nodoc
class _$StreamInfoCopyWithImpl<$Res, $Val extends StreamInfo>
    implements $StreamInfoCopyWith<$Res> {
  _$StreamInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channel = freezed,
    Object? feed = freezed,
    Object? title = freezed,
    Object? url = freezed,
    Object? referrer = freezed,
    Object? userAgent = freezed,
    Object? quality = freezed,
  }) {
    return _then(_value.copyWith(
      channel: freezed == channel
          ? _value.channel
          : channel // ignore: cast_nullable_to_non_nullable
              as String?,
      feed: freezed == feed
          ? _value.feed
          : feed // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      referrer: freezed == referrer
          ? _value.referrer
          : referrer // ignore: cast_nullable_to_non_nullable
              as String?,
      userAgent: freezed == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String?,
      quality: freezed == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StreamInfoImplCopyWith<$Res>
    implements $StreamInfoCopyWith<$Res> {
  factory _$$StreamInfoImplCopyWith(
          _$StreamInfoImpl value, $Res Function(_$StreamInfoImpl) then) =
      __$$StreamInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? channel,
      String? feed,
      String? title,
      String? url,
      String? referrer,
      @JsonKey(name: 'user_agent') String? userAgent,
      String? quality});
}

/// @nodoc
class __$$StreamInfoImplCopyWithImpl<$Res>
    extends _$StreamInfoCopyWithImpl<$Res, _$StreamInfoImpl>
    implements _$$StreamInfoImplCopyWith<$Res> {
  __$$StreamInfoImplCopyWithImpl(
      _$StreamInfoImpl _value, $Res Function(_$StreamInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channel = freezed,
    Object? feed = freezed,
    Object? title = freezed,
    Object? url = freezed,
    Object? referrer = freezed,
    Object? userAgent = freezed,
    Object? quality = freezed,
  }) {
    return _then(_$StreamInfoImpl(
      channel: freezed == channel
          ? _value.channel
          : channel // ignore: cast_nullable_to_non_nullable
              as String?,
      feed: freezed == feed
          ? _value.feed
          : feed // ignore: cast_nullable_to_non_nullable
              as String?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      referrer: freezed == referrer
          ? _value.referrer
          : referrer // ignore: cast_nullable_to_non_nullable
              as String?,
      userAgent: freezed == userAgent
          ? _value.userAgent
          : userAgent // ignore: cast_nullable_to_non_nullable
              as String?,
      quality: freezed == quality
          ? _value.quality
          : quality // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StreamInfoImpl implements _StreamInfo {
  const _$StreamInfoImpl(
      {this.channel,
      this.feed,
      this.title,
      this.url,
      this.referrer,
      @JsonKey(name: 'user_agent') this.userAgent,
      this.quality});

  factory _$StreamInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$StreamInfoImplFromJson(json);

  @override
  final String? channel;
// CAN BE NULL in API!
  @override
  final String? feed;
  @override
  final String? title;
  @override
  final String? url;
// CAN BE NULL in API!
  @override
  final String? referrer;
  @override
  @JsonKey(name: 'user_agent')
  final String? userAgent;
  @override
  final String? quality;

  @override
  String toString() {
    return 'StreamInfo(channel: $channel, feed: $feed, title: $title, url: $url, referrer: $referrer, userAgent: $userAgent, quality: $quality)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamInfoImpl &&
            (identical(other.channel, channel) || other.channel == channel) &&
            (identical(other.feed, feed) || other.feed == feed) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.referrer, referrer) ||
                other.referrer == referrer) &&
            (identical(other.userAgent, userAgent) ||
                other.userAgent == userAgent) &&
            (identical(other.quality, quality) || other.quality == quality));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, channel, feed, title, url, referrer, userAgent, quality);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamInfoImplCopyWith<_$StreamInfoImpl> get copyWith =>
      __$$StreamInfoImplCopyWithImpl<_$StreamInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StreamInfoImplToJson(
      this,
    );
  }
}

abstract class _StreamInfo implements StreamInfo {
  const factory _StreamInfo(
      {final String? channel,
      final String? feed,
      final String? title,
      final String? url,
      final String? referrer,
      @JsonKey(name: 'user_agent') final String? userAgent,
      final String? quality}) = _$StreamInfoImpl;

  factory _StreamInfo.fromJson(Map<String, dynamic> json) =
      _$StreamInfoImpl.fromJson;

  @override
  String? get channel;
  @override // CAN BE NULL in API!
  String? get feed;
  @override
  String? get title;
  @override
  String? get url;
  @override // CAN BE NULL in API!
  String? get referrer;
  @override
  @JsonKey(name: 'user_agent')
  String? get userAgent;
  @override
  String? get quality;
  @override
  @JsonKey(ignore: true)
  _$$StreamInfoImplCopyWith<_$StreamInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChannelInfo _$ChannelInfoFromJson(Map<String, dynamic> json) {
  return _ChannelInfo.fromJson(json);
}

/// @nodoc
mixin _$ChannelInfo {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'alt_names')
  List<String> get altNames => throw _privateConstructorUsedError;
  String? get network => throw _privateConstructorUsedError;
  List<String> get owners => throw _privateConstructorUsedError;
  String get country =>
      throw _privateConstructorUsedError; // Can be null in API
  List<String> get categories => throw _privateConstructorUsedError;
  @JsonKey(name: 'is_nsfw')
  bool get isNsfw => throw _privateConstructorUsedError;
  String? get launched => throw _privateConstructorUsedError;
  String? get closed => throw _privateConstructorUsedError;
  @JsonKey(name: 'replaced_by')
  String? get replacedBy => throw _privateConstructorUsedError;
  String? get website => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChannelInfoCopyWith<ChannelInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChannelInfoCopyWith<$Res> {
  factory $ChannelInfoCopyWith(
          ChannelInfo value, $Res Function(ChannelInfo) then) =
      _$ChannelInfoCopyWithImpl<$Res, ChannelInfo>;
  @useResult
  $Res call(
      {String id,
      String name,
      @JsonKey(name: 'alt_names') List<String> altNames,
      String? network,
      List<String> owners,
      String country,
      List<String> categories,
      @JsonKey(name: 'is_nsfw') bool isNsfw,
      String? launched,
      String? closed,
      @JsonKey(name: 'replaced_by') String? replacedBy,
      String? website});
}

/// @nodoc
class _$ChannelInfoCopyWithImpl<$Res, $Val extends ChannelInfo>
    implements $ChannelInfoCopyWith<$Res> {
  _$ChannelInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? altNames = null,
    Object? network = freezed,
    Object? owners = null,
    Object? country = null,
    Object? categories = null,
    Object? isNsfw = null,
    Object? launched = freezed,
    Object? closed = freezed,
    Object? replacedBy = freezed,
    Object? website = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      altNames: null == altNames
          ? _value.altNames
          : altNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as String?,
      owners: null == owners
          ? _value.owners
          : owners // ignore: cast_nullable_to_non_nullable
              as List<String>,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      categories: null == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isNsfw: null == isNsfw
          ? _value.isNsfw
          : isNsfw // ignore: cast_nullable_to_non_nullable
              as bool,
      launched: freezed == launched
          ? _value.launched
          : launched // ignore: cast_nullable_to_non_nullable
              as String?,
      closed: freezed == closed
          ? _value.closed
          : closed // ignore: cast_nullable_to_non_nullable
              as String?,
      replacedBy: freezed == replacedBy
          ? _value.replacedBy
          : replacedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      website: freezed == website
          ? _value.website
          : website // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChannelInfoImplCopyWith<$Res>
    implements $ChannelInfoCopyWith<$Res> {
  factory _$$ChannelInfoImplCopyWith(
          _$ChannelInfoImpl value, $Res Function(_$ChannelInfoImpl) then) =
      __$$ChannelInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @JsonKey(name: 'alt_names') List<String> altNames,
      String? network,
      List<String> owners,
      String country,
      List<String> categories,
      @JsonKey(name: 'is_nsfw') bool isNsfw,
      String? launched,
      String? closed,
      @JsonKey(name: 'replaced_by') String? replacedBy,
      String? website});
}

/// @nodoc
class __$$ChannelInfoImplCopyWithImpl<$Res>
    extends _$ChannelInfoCopyWithImpl<$Res, _$ChannelInfoImpl>
    implements _$$ChannelInfoImplCopyWith<$Res> {
  __$$ChannelInfoImplCopyWithImpl(
      _$ChannelInfoImpl _value, $Res Function(_$ChannelInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? altNames = null,
    Object? network = freezed,
    Object? owners = null,
    Object? country = null,
    Object? categories = null,
    Object? isNsfw = null,
    Object? launched = freezed,
    Object? closed = freezed,
    Object? replacedBy = freezed,
    Object? website = freezed,
  }) {
    return _then(_$ChannelInfoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      altNames: null == altNames
          ? _value._altNames
          : altNames // ignore: cast_nullable_to_non_nullable
              as List<String>,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as String?,
      owners: null == owners
          ? _value._owners
          : owners // ignore: cast_nullable_to_non_nullable
              as List<String>,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as String,
      categories: null == categories
          ? _value._categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isNsfw: null == isNsfw
          ? _value.isNsfw
          : isNsfw // ignore: cast_nullable_to_non_nullable
              as bool,
      launched: freezed == launched
          ? _value.launched
          : launched // ignore: cast_nullable_to_non_nullable
              as String?,
      closed: freezed == closed
          ? _value.closed
          : closed // ignore: cast_nullable_to_non_nullable
              as String?,
      replacedBy: freezed == replacedBy
          ? _value.replacedBy
          : replacedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      website: freezed == website
          ? _value.website
          : website // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChannelInfoImpl implements _ChannelInfo {
  const _$ChannelInfoImpl(
      {required this.id,
      required this.name,
      @JsonKey(name: 'alt_names') final List<String> altNames = const [],
      this.network,
      final List<String> owners = const [],
      this.country = '',
      final List<String> categories = const [],
      @JsonKey(name: 'is_nsfw') this.isNsfw = false,
      this.launched,
      this.closed,
      @JsonKey(name: 'replaced_by') this.replacedBy,
      this.website})
      : _altNames = altNames,
        _owners = owners,
        _categories = categories;

  factory _$ChannelInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChannelInfoImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  final List<String> _altNames;
  @override
  @JsonKey(name: 'alt_names')
  List<String> get altNames {
    if (_altNames is EqualUnmodifiableListView) return _altNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_altNames);
  }

  @override
  final String? network;
  final List<String> _owners;
  @override
  @JsonKey()
  List<String> get owners {
    if (_owners is EqualUnmodifiableListView) return _owners;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_owners);
  }

  @override
  @JsonKey()
  final String country;
// Can be null in API
  final List<String> _categories;
// Can be null in API
  @override
  @JsonKey()
  List<String> get categories {
    if (_categories is EqualUnmodifiableListView) return _categories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categories);
  }

  @override
  @JsonKey(name: 'is_nsfw')
  final bool isNsfw;
  @override
  final String? launched;
  @override
  final String? closed;
  @override
  @JsonKey(name: 'replaced_by')
  final String? replacedBy;
  @override
  final String? website;

  @override
  String toString() {
    return 'ChannelInfo(id: $id, name: $name, altNames: $altNames, network: $network, owners: $owners, country: $country, categories: $categories, isNsfw: $isNsfw, launched: $launched, closed: $closed, replacedBy: $replacedBy, website: $website)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChannelInfoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._altNames, _altNames) &&
            (identical(other.network, network) || other.network == network) &&
            const DeepCollectionEquality().equals(other._owners, _owners) &&
            (identical(other.country, country) || other.country == country) &&
            const DeepCollectionEquality()
                .equals(other._categories, _categories) &&
            (identical(other.isNsfw, isNsfw) || other.isNsfw == isNsfw) &&
            (identical(other.launched, launched) ||
                other.launched == launched) &&
            (identical(other.closed, closed) || other.closed == closed) &&
            (identical(other.replacedBy, replacedBy) ||
                other.replacedBy == replacedBy) &&
            (identical(other.website, website) || other.website == website));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(_altNames),
      network,
      const DeepCollectionEquality().hash(_owners),
      country,
      const DeepCollectionEquality().hash(_categories),
      isNsfw,
      launched,
      closed,
      replacedBy,
      website);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChannelInfoImplCopyWith<_$ChannelInfoImpl> get copyWith =>
      __$$ChannelInfoImplCopyWithImpl<_$ChannelInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChannelInfoImplToJson(
      this,
    );
  }
}

abstract class _ChannelInfo implements ChannelInfo {
  const factory _ChannelInfo(
      {required final String id,
      required final String name,
      @JsonKey(name: 'alt_names') final List<String> altNames,
      final String? network,
      final List<String> owners,
      final String country,
      final List<String> categories,
      @JsonKey(name: 'is_nsfw') final bool isNsfw,
      final String? launched,
      final String? closed,
      @JsonKey(name: 'replaced_by') final String? replacedBy,
      final String? website}) = _$ChannelInfoImpl;

  factory _ChannelInfo.fromJson(Map<String, dynamic> json) =
      _$ChannelInfoImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @JsonKey(name: 'alt_names')
  List<String> get altNames;
  @override
  String? get network;
  @override
  List<String> get owners;
  @override
  String get country;
  @override // Can be null in API
  List<String> get categories;
  @override
  @JsonKey(name: 'is_nsfw')
  bool get isNsfw;
  @override
  String? get launched;
  @override
  String? get closed;
  @override
  @JsonKey(name: 'replaced_by')
  String? get replacedBy;
  @override
  String? get website;
  @override
  @JsonKey(ignore: true)
  _$$ChannelInfoImplCopyWith<_$ChannelInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LogoInfo _$LogoInfoFromJson(Map<String, dynamic> json) {
  return _LogoInfo.fromJson(json);
}

/// @nodoc
mixin _$LogoInfo {
  String? get channel => throw _privateConstructorUsedError; // Can be null
  String? get feed => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;
  int? get width => throw _privateConstructorUsedError;
  int? get height => throw _privateConstructorUsedError;
  String? get format => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LogoInfoCopyWith<LogoInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LogoInfoCopyWith<$Res> {
  factory $LogoInfoCopyWith(LogoInfo value, $Res Function(LogoInfo) then) =
      _$LogoInfoCopyWithImpl<$Res, LogoInfo>;
  @useResult
  $Res call(
      {String? channel,
      String? feed,
      List<String> tags,
      int? width,
      int? height,
      String? format,
      String? url});
}

/// @nodoc
class _$LogoInfoCopyWithImpl<$Res, $Val extends LogoInfo>
    implements $LogoInfoCopyWith<$Res> {
  _$LogoInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channel = freezed,
    Object? feed = freezed,
    Object? tags = null,
    Object? width = freezed,
    Object? height = freezed,
    Object? format = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      channel: freezed == channel
          ? _value.channel
          : channel // ignore: cast_nullable_to_non_nullable
              as String?,
      feed: freezed == feed
          ? _value.feed
          : feed // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LogoInfoImplCopyWith<$Res>
    implements $LogoInfoCopyWith<$Res> {
  factory _$$LogoInfoImplCopyWith(
          _$LogoInfoImpl value, $Res Function(_$LogoInfoImpl) then) =
      __$$LogoInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? channel,
      String? feed,
      List<String> tags,
      int? width,
      int? height,
      String? format,
      String? url});
}

/// @nodoc
class __$$LogoInfoImplCopyWithImpl<$Res>
    extends _$LogoInfoCopyWithImpl<$Res, _$LogoInfoImpl>
    implements _$$LogoInfoImplCopyWith<$Res> {
  __$$LogoInfoImplCopyWithImpl(
      _$LogoInfoImpl _value, $Res Function(_$LogoInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channel = freezed,
    Object? feed = freezed,
    Object? tags = null,
    Object? width = freezed,
    Object? height = freezed,
    Object? format = freezed,
    Object? url = freezed,
  }) {
    return _then(_$LogoInfoImpl(
      channel: freezed == channel
          ? _value.channel
          : channel // ignore: cast_nullable_to_non_nullable
              as String?,
      feed: freezed == feed
          ? _value.feed
          : feed // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LogoInfoImpl implements _LogoInfo {
  const _$LogoInfoImpl(
      {this.channel,
      this.feed,
      final List<String> tags = const [],
      this.width,
      this.height,
      this.format,
      this.url})
      : _tags = tags;

  factory _$LogoInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$LogoInfoImplFromJson(json);

  @override
  final String? channel;
// Can be null
  @override
  final String? feed;
  final List<String> _tags;
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final int? width;
  @override
  final int? height;
  @override
  final String? format;
  @override
  final String? url;

  @override
  String toString() {
    return 'LogoInfo(channel: $channel, feed: $feed, tags: $tags, width: $width, height: $height, format: $format, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LogoInfoImpl &&
            (identical(other.channel, channel) || other.channel == channel) &&
            (identical(other.feed, feed) || other.feed == feed) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, channel, feed,
      const DeepCollectionEquality().hash(_tags), width, height, format, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LogoInfoImplCopyWith<_$LogoInfoImpl> get copyWith =>
      __$$LogoInfoImplCopyWithImpl<_$LogoInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LogoInfoImplToJson(
      this,
    );
  }
}

abstract class _LogoInfo implements LogoInfo {
  const factory _LogoInfo(
      {final String? channel,
      final String? feed,
      final List<String> tags,
      final int? width,
      final int? height,
      final String? format,
      final String? url}) = _$LogoInfoImpl;

  factory _LogoInfo.fromJson(Map<String, dynamic> json) =
      _$LogoInfoImpl.fromJson;

  @override
  String? get channel;
  @override // Can be null
  String? get feed;
  @override
  List<String> get tags;
  @override
  int? get width;
  @override
  int? get height;
  @override
  String? get format;
  @override
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$LogoInfoImplCopyWith<_$LogoInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
